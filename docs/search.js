window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "src", "modulename": "src", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.dataIO", "modulename": "src.dataIO", "kind": "module", "doc": "<p>Module for handling data input/output operations related to trajectory\nanalysis.</p>\n\n<p>This module provides functions and a class (<code>DataIO</code>) for managing file\npaths, reading trajectory data from CSV files, processing them,\nand extracting metadata like animal names.</p>\n"}, {"fullname": "src.dataIO.get_file_paths", "modulename": "src.dataIO", "qualname": "get_file_paths", "kind": "function", "doc": "<p>Retrieves a list of file paths from a given directory.</p>\n\n<p>Args:\n    directory (str): The path to the directory containing the files.</p>\n\n<p>Returns:\n    list: A list of full file paths to all files in the directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">directory</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.dataIO.create_output_directory", "modulename": "src.dataIO", "qualname": "create_output_directory", "kind": "function", "doc": "<p>Creates an output directory if it does not already exist.</p>\n\n<p>Args:\n    base_path (str): The base path where the directory should be created.\n    dir_name (str): The name of the output directory.</p>\n\n<p>Returns:\n    str: The full path to the created directory.</p>\n\n<p>Raises:\n    OSError: If the directory cannot be created due to system errors.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">base_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">dir_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.dataIO.DataIO", "modulename": "src.dataIO", "qualname": "DataIO", "kind": "class", "doc": "<p>A class providing static methods for handling trajectory\ndata input and processing.</p>\n\n<p>This class includes methods to open and preprocess\ntrajectory data files, ensuring they are formatted correctly\nfor further analysis.</p>\n"}, {"fullname": "src.dataIO.DataIO.open_for_scaling_laws", "modulename": "src.dataIO", "qualname": "DataIO.open_for_scaling_laws", "kind": "function", "doc": "<p>Opens a CSV file and converts it into a TrajectoriesFrame suitable\nfor scaling law analysis.</p>\n\n<p>Args:\n    csv_path (str): The path to the CSV file containing\n        trajectory data.</p>\n\n<p>Returns:\n    TrajectoriesFrame: A structured data frame with the\n        loaded trajectory data.</p>\n\n<p>Raises:\n    FileNotFoundError: If the specified file does not exist.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.dataIO.DataIO.open_for_infostop", "modulename": "src.dataIO", "qualname": "DataIO.open_for_infostop", "kind": "function", "doc": "<p>Opens a CSV file and processes it for use in Infostop analysis.\nFilters out rows with missing values and converts coordinates\nto a different CRS.</p>\n\n<p>Args:\n    csv_path (str): Path to the CSV file containing the raw data.</p>\n\n<p>Returns:\n    TrajectoriesFrame: Processed trajectory data with valid\n    coordinates and datetimes.</p>\n\n<p>Raises:\n    FileNotFoundError: If the CSV file is not found at the given path.\n    ValueError: If the CSV file contains invalid or malformed data.\n    KeyError: If expected columns ('datetime', 'user_id', 'geometry',\n        'lon', 'lat') are missing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.dataIO.DataIO.get_animal_name", "modulename": "src.dataIO", "qualname": "DataIO.get_animal_name", "kind": "function", "doc": "<p>Extracts the animal's name from the file path by parsing\nthe file name.</p>\n\n<p>Args:\n    csv_path (str): Path to the CSV file.</p>\n\n<p>Returns:\n    str: Extracted animal name from the file name.</p>\n\n<p>Raises:\n    FileNotFoundError: If the file does not exist at the given path.\n    ValueError: If the file name does not conform to the\n        expected format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csv_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.istop", "modulename": "src.istop", "kind": "module", "doc": "<p>Module for data analysis and labeling using the Infostop algorithm.</p>\n\n<p>This module provides functionality for analyzing trajectory data\nand identifying \"stops\" and \"moves\" using the Infostop algorithm.\nIt includes multiple classes and methods designed to handle the\nfollowing tasks:</p>\n\n<ul>\n<li>Filtering and processing trajectory data.</li>\n<li>Applying the Infostop algorithm to detect stops based on location and time.</li>\n<li>Computing and visualizing optimal parameters for the Infostop algorithm.</li>\n<li>Generating reports and plots for analysis.</li>\n</ul>\n"}, {"fullname": "src.istop.DataAnalystInfostop", "modulename": "src.istop", "qualname": "DataAnalystInfostop", "kind": "class", "doc": "<p>A class responsible for generating data analysis reports in PDF format.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>pdf_object : FPDF\n    PDF instance to which the analysis results will be added.</p>\n"}, {"fullname": "src.istop.DataAnalystInfostop.__init__", "modulename": "src.istop", "qualname": "DataAnalystInfostop.__init__", "kind": "function", "doc": "<p>Initializes the DataAnalystInfostop with a given PDF instance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>pdf_object : FPDF\n    PDF instance where analysis results will be written.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pdf_object</span><span class=\"p\">:</span> <span class=\"n\">fpdf</span><span class=\"o\">.</span><span class=\"n\">fpdf</span><span class=\"o\">.</span><span class=\"n\">FPDF</span>, </span><span class=\"param\"><span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "src.istop.DataAnalystInfostop.pdf_object", "modulename": "src.istop", "qualname": "DataAnalystInfostop.pdf_object", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.DataAnalystInfostop.output_path", "modulename": "src.istop", "qualname": "DataAnalystInfostop.output_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.DataAnalystInfostop.generate_raport", "modulename": "src.istop", "qualname": "DataAnalystInfostop.generate_raport", "kind": "function", "doc": "<p>Generates a data analysis report, adding results and visualizations\nto the PDF.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : TrajectoriesFrame\n    Input data for analysis.\ndata_analyst_no : int\n    Analysis identifier used in titles and filenames.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Executes a data analysis pipeline, generating various statistical\nmetrics and plots, which are sequentially added to the PDF document.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>,</span><span class=\"param\">\t<span class=\"n\">data_analyst_no</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.istop.DataFilter", "modulename": "src.istop", "qualname": "DataFilter", "kind": "class", "doc": "<p>A class responsible for filtering, processing, and sorting\nanimal trajectory data.</p>\n\n<p>Attributes:\n    pdf_object (FPDF): PDF object used for documenting\n        the data processing steps.\n    allowed_minutes (list): List of allowed temporal\n        resolutions in minutes.\n    day_window (int): Time window in days for selecting\n        the best periods of data.</p>\n"}, {"fullname": "src.istop.DataFilter.__init__", "modulename": "src.istop", "qualname": "DataFilter.__init__", "kind": "function", "doc": "<p>Initializes the DataFilter object with a PDF for logging\nand default settings.</p>\n\n<p>Args:\n    pdf_object (FPDF): The PDF object for adding logging\n        information.</p>\n\n<p>Attributes:\n    allowed_minutes (list): A list of allowed temporal\n        resolutions (in minutes).\n    day_window (int): The number of days considered for\n        the time window.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pdf_object</span><span class=\"p\">:</span> <span class=\"n\">fpdf</span><span class=\"o\">.</span><span class=\"n\">fpdf</span><span class=\"o\">.</span><span class=\"n\">FPDF</span></span>)</span>"}, {"fullname": "src.istop.DataFilter.pdf_object", "modulename": "src.istop", "qualname": "DataFilter.pdf_object", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.DataFilter.allowed_minutes", "modulename": "src.istop", "qualname": "DataFilter.allowed_minutes", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.DataFilter.day_window", "modulename": "src.istop", "qualname": "DataFilter.day_window", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.DataFilter.select_best_period", "modulename": "src.istop", "qualname": "DataFilter.select_best_period", "kind": "function", "doc": "<p>Selects the best periods of data to maximize coverage.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The input data containing user trajectories.</p>\n\n<p>Returns:\n    TrajectoriesFrame: A TrajectoriesFrame object containing\n        the selected data.</p>\n\n<p>Raises:\n    ValueError: If there is an error during data selection.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.istop.DataFilter.filter_data", "modulename": "src.istop", "qualname": "DataFilter.filter_data", "kind": "function", "doc": "<p>Filters the data based on various user statistics.</p>\n\n<p>Args:\n    data (pd.DataFrame): The input data containing user trajectories.</p>\n\n<p>Returns:\n    TrajectoriesFrame: A TrajectoriesFrame object containing\n        the filtered data.</p>\n\n<p>Raises:\n    ValueError: If there is an error during filtering.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.istop.DataFilter.sort_data", "modulename": "src.istop", "qualname": "DataFilter.sort_data", "kind": "function", "doc": "<p>Sorts and prepares trajectory data for infostop processing.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The input trajectory data.</p>\n\n<p>Returns:\n    pd.DataFrame: A sorted and prepared DataFrame with columns\n        ['user_id', 'time', 'latitude', 'longitude'].</p>\n\n<p>Raises:\n    ValueError: If there is an error during sorting or preparation.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.istop.LabelsCalc", "modulename": "src.istop", "qualname": "LabelsCalc", "kind": "class", "doc": "<p>A class for processing and labeling movement data using\nthe Infostop algorithm. Includes functionality for parameter optimization,\ntrajectory segmentation, and result visualization.</p>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>pdf_object : FPDF\n    A PDF object for documenting results and calculations.\noutput_path : str\n    The directory where plots and other outputs will be saved.</p>\n"}, {"fullname": "src.istop.LabelsCalc.__init__", "modulename": "src.istop", "qualname": "LabelsCalc.__init__", "kind": "function", "doc": "<p>Initialize the LabelsCalc instance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>pdf_object : FPDF\n    PDF object for logging and documentation.\noutput_path : str\n    Path to save generated plots and outputs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pdf_object</span><span class=\"p\">:</span> <span class=\"n\">fpdf</span><span class=\"o\">.</span><span class=\"n\">fpdf</span><span class=\"o\">.</span><span class=\"n\">FPDF</span>, </span><span class=\"param\"><span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "src.istop.LabelsCalc.pdf_object", "modulename": "src.istop", "qualname": "LabelsCalc.pdf_object", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.LabelsCalc.output_path", "modulename": "src.istop", "qualname": "LabelsCalc.output_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.LabelsCalc.calculate_infostop", "modulename": "src.istop", "qualname": "LabelsCalc.calculate_infostop", "kind": "function", "doc": "<p>Perform Infostop calculation, including sensitivity analysis\nand trajectory labeling.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>data : pd.DataFrame\n    Input data containing user trajectories.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pd.DataFrame\n    Final labeled trajectories.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.istop.InfoStopData", "modulename": "src.istop", "qualname": "InfoStopData", "kind": "class", "doc": "<p>A class responsible for analyzing animal data and generating reports in\nPDF and CSV formats.</p>\n\n<p>Attributes:\n    clean_data (TrajectoriesFrame): Raw input data related to animals.\n    animal_name (str): The name of the analyzed animal.\n    output_dir (str): Path to the main output directory.\n    output_dir_animal (str): Path to the output directory for the\n        specific animal.\n    pdf (FPDF): FPDF object used for generating PDF reports.</p>\n"}, {"fullname": "src.istop.InfoStopData.__init__", "modulename": "src.istop", "qualname": "InfoStopData.__init__", "kind": "function", "doc": "<p>Initializes the InfoStopData object, creates an output directory,\nand sets up a PDF report.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The input data for analysis.\n    data_name (str): The name of the analyzed animal.\n    output_dir (str): Path to the main output directory.</p>\n\n<p>Raises:\n    FileExistsError: If the output directory for the animal\n        already exists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>,</span><span class=\"param\">\t<span class=\"n\">data_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">output_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "src.istop.InfoStopData.clean_data", "modulename": "src.istop", "qualname": "InfoStopData.clean_data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.InfoStopData.animal_name", "modulename": "src.istop", "qualname": "InfoStopData.animal_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.InfoStopData.output_dir", "modulename": "src.istop", "qualname": "InfoStopData.output_dir", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.InfoStopData.output_dir_animal", "modulename": "src.istop", "qualname": "InfoStopData.output_dir_animal", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.InfoStopData.pdf", "modulename": "src.istop", "qualname": "InfoStopData.pdf", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.istop.InfoStopData.calculate_all", "modulename": "src.istop", "qualname": "InfoStopData.calculate_all", "kind": "function", "doc": "<p>Performs a complete analysis of the data, generates reports\nin PDF format, and saves the results to a CSV file.</p>\n\n<p>Process:\n    1. Generates an initial report.\n    2. Selects the best period of data.\n    3. Filters the data.\n    4. Sorts the data.\n    5. Processes the data using the infostop module.\n    6. Exports results to CSV and PDF files.</p>\n\n<p>Raises:\n    FileNotFoundError: If a required file is missing during\n        the process.\n    ValueError: If the data contains invalid values.\n    Exception: For any unexpected errors that occur during\n        the process.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws", "modulename": "src.laws", "kind": "module", "doc": "<p>Module for data processing, statistical analysis,\nand model fitting using Flexation and related methods.</p>\n\n<p>This module includes functionality for handling data related\nto animal movement, applying various filtering and preprocessing\ntechniques, and fitting statistical models to segmented data based\non flexation points.</p>\n"}, {"fullname": "src.laws.Curves", "modulename": "src.laws", "qualname": "Curves", "kind": "class", "doc": "<p>A class containing various static methods to model different\nmathematical curves. These methods take input values and parameters\nto compute specific mathematical transformations.</p>\n"}, {"fullname": "src.laws.Curves.linear", "modulename": "src.laws", "qualname": "Curves.linear", "kind": "function", "doc": "<p>Computes a linear transformation: y = a*x.</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Slope coefficient.\nb (float): Scaling coefficient.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.expon", "modulename": "src.laws", "qualname": "Curves.expon", "kind": "function", "doc": "<p>Computes an exponential curve: y = a * x^b.</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Base scaling coefficient.\nb (float): Exponent.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.expon_neg", "modulename": "src.laws", "qualname": "Curves.expon_neg", "kind": "function", "doc": "<p>Computes a negative exponential curve: y = a * x^(-b).</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Scaling coefficient.\nb (float): Negative exponent.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.euler", "modulename": "src.laws", "qualname": "Curves.euler", "kind": "function", "doc": "<p>Computes an Euler's exponential curve: y = a * e^(b * x).</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Scaling coefficient.\nb (float): Exponent coefficient.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.power", "modulename": "src.laws", "qualname": "Curves.power", "kind": "function", "doc": "<p>Computes a power curve: y = a * b^x.</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Scaling coefficient.\nb (float): Base.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.power_neg", "modulename": "src.laws", "qualname": "Curves.power_neg", "kind": "function", "doc": "<p>Computes a negative power curve: y = a * b^(-x).</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Scaling coefficient.\nb (float): Base.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.logar", "modulename": "src.laws", "qualname": "Curves.logar", "kind": "function", "doc": "<p>Computes a logarithmic curve: y = a + b * log(x).</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Constant offset.\nb (float): Logarithmic scaling factor.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.cubic", "modulename": "src.laws", "qualname": "Curves.cubic", "kind": "function", "doc": "<p>Computes a cubic curve: y = a<em>x^3 + b</em>x^2 + c*x + d.</p>\n\n<p>Parameters:\nx (array-like): Input values.\na, b, c, d (float): Coefficients for cubic, quadratic,\n    linear, and constant terms.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.sigmoid", "modulename": "src.laws", "qualname": "Curves.sigmoid", "kind": "function", "doc": "<p>Computes a sigmoid curve: y = 1 / (1 + exp(a*x)).</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Scaling factor.\nb (float): Offset factor.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.quad", "modulename": "src.laws", "qualname": "Curves.quad", "kind": "function", "doc": "<p>Computes a quadratic curve: y = a<em>x^2 + b</em>x + c.</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Coefficient for the quadratic term.\nb (float): Coefficient for the linear term.\nc (float): Constant term.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.four", "modulename": "src.laws", "qualname": "Curves.four", "kind": "function", "doc": "<p>Computes a quartic curve: y = a<em>x^4 + b</em>x^3 + c<em>x^2 + d</em>x + e.</p>\n\n<p>Parameters:\nx (array-like): Input values.\na, b, c, d, e (float): Coefficients for quartic, cubic,\nquadratic, linear, and constant terms.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">c</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.zipf", "modulename": "src.laws", "qualname": "Curves.zipf", "kind": "function", "doc": "<p>Computes a Zipf curve: y = 1 / (x + a)^b.</p>\n\n<p>Parameters:\nx (array-like): Input values.\na (float): Offset to prevent division by zero.\nb (float): Exponent for scaling.</p>\n\n<p>Returns:\narray-like: Transformed values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Curves.power_law", "modulename": "src.laws", "qualname": "Curves.power_law", "kind": "function", "doc": "<p>Power-law function used to model the number of unique places\nvisited over time.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.DistributionFitingTools", "modulename": "src.laws", "qualname": "DistributionFitingTools", "kind": "class", "doc": "<p>A class containing tools for fitting distributions and models to data.</p>\n"}, {"fullname": "src.laws.DistributionFitingTools.curves", "modulename": "src.laws", "qualname": "DistributionFitingTools.curves", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.DistributionFitingTools.model_choose", "modulename": "src.laws", "qualname": "DistributionFitingTools.model_choose", "kind": "function", "doc": "<p>Chooses the best fitting model from a set of predefined curves\nbased on AICc.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>vals : pandas.Series\n    The data to which the models are fitted.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple\n    The best fit model, its name, parameters, and a DataFrame\n    containing model information.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">vals</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats", "modulename": "src.laws", "qualname": "Stats", "kind": "class", "doc": "<p>A utility class for calculating various statistics and metrics\nfrom a TrajectoriesFrame.</p>\n"}, {"fullname": "src.laws.Stats.get_animals_no", "modulename": "src.laws", "qualname": "Stats.get_animals_no", "kind": "function", "doc": "<p>Get the total number of unique animals in the dataset.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with animal trajectories.</p>\n\n<p>Returns:\n    int: The number of unique animals.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_period", "modulename": "src.laws", "qualname": "Stats.get_period", "kind": "function", "doc": "<p>Get the total observation period of the dataset.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data containing\n        'start' and 'end' columns.</p>\n\n<p>Returns:\n    pd.Timedelta: The duration between the earliest start\n        and the latest end.</p>\n\n<p>Raises:\n    KeyError: If columns 'start' or 'end' are missing\n        in the dataset.\n    ValueError: If columns 'start' or 'end' contain\n        invalid datetime values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_min_labels_no_after_filtration", "modulename": "src.laws", "qualname": "Stats.get_min_labels_no_after_filtration", "kind": "function", "doc": "<p>Get the users with the minimum number of unique labels\nafter filtration.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'user_id'\n        and 'labels' columns.</p>\n\n<p>Returns:\n    pd.Series: Users with the minimum unique label count.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_mean_labels_no_after_filtration", "modulename": "src.laws", "qualname": "Stats.get_mean_labels_no_after_filtration", "kind": "function", "doc": "<p>Get the users mean number of unique labels\nafter filtration.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'user_id'\n        and 'labels' columns.</p>\n\n<p>Returns:\n    int: Users mean no. unique label count.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_std_labels_no_after_filtration", "modulename": "src.laws", "qualname": "Stats.get_std_labels_no_after_filtration", "kind": "function", "doc": "<p>Get the users std of unique labels\nafter filtration.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'user_id'\n        and 'labels' columns.</p>\n\n<p>Returns:\n    int: Users mean no. unique label count.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_min_records_no_before_filtration", "modulename": "src.laws", "qualname": "Stats.get_min_records_no_before_filtration", "kind": "function", "doc": "<p>Get the animals with the minimum number of records\nbefore filtration.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'animal_id'\n        and 'time' columns.</p>\n\n<p>Returns:\n    pd.Series: Animals with the minimum number of records.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_mean_records_no_before_filtration", "modulename": "src.laws", "qualname": "Stats.get_mean_records_no_before_filtration", "kind": "function", "doc": "<p>Get the mean number of records\nbefore filtration.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'animal_id'\n        and 'time' columns.</p>\n\n<p>Returns:\n    int: mean number of records.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_std_records_no_before_filtration", "modulename": "src.laws", "qualname": "Stats.get_std_records_no_before_filtration", "kind": "function", "doc": "<p>Get the mean number of records\nbefore filtration.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'animal_id'\n        and 'time' columns.</p>\n\n<p>Returns:\n    int: mean number of records.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_mean_periods", "modulename": "src.laws", "qualname": "Stats.get_mean_periods", "kind": "function", "doc": "<p>Get the mean period between start and end times.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'start'\n        and 'end' columns.</p>\n\n<p>Returns:\n    float: The mean period in days.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_min_periods", "modulename": "src.laws", "qualname": "Stats.get_min_periods", "kind": "function", "doc": "<p>Get the minimum period between start and end times.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'start'\n        and 'end' columns.</p>\n\n<p>Returns:\n    float: The minimum period in days.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_max_periods", "modulename": "src.laws", "qualname": "Stats.get_max_periods", "kind": "function", "doc": "<p>Get the maximum period between start and end times.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'start'\n        and 'end' columns.</p>\n\n<p>Returns:\n    float: The maximum period in days.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_std_periods", "modulename": "src.laws", "qualname": "Stats.get_std_periods", "kind": "function", "doc": "<p>Get the std of period between start and end times.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data with 'start'\n        and 'end' columns.</p>\n\n<p>Returns:\n    float: The std period in days.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">_libs</span><span class=\"o\">.</span><span class=\"n\">tslibs</span><span class=\"o\">.</span><span class=\"n\">timedeltas</span><span class=\"o\">.</span><span class=\"n\">Timedelta</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_overall_area", "modulename": "src.laws", "qualname": "Stats.get_overall_area", "kind": "function", "doc": "<p>Get the overall area covered by the trajectories.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input spatial data.</p>\n\n<p>Returns:\n    float: The overall area in hectares.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_mean_area", "modulename": "src.laws", "qualname": "Stats.get_mean_area", "kind": "function", "doc": "<p>Get the mean area covered by trajectories per user.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data.</p>\n\n<p>Returns:\n    float: The mean area in hectares.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_min_area", "modulename": "src.laws", "qualname": "Stats.get_min_area", "kind": "function", "doc": "<p>Get the min area covered by trajectories per user.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data.</p>\n\n<p>Returns:\n    float: The min area in hectares.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_max_area", "modulename": "src.laws", "qualname": "Stats.get_max_area", "kind": "function", "doc": "<p>Get the max area covered by trajectories per user.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data.</p>\n\n<p>Returns:\n    float: The max area in hectares.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Stats.get_std_area", "modulename": "src.laws", "qualname": "Stats.get_std_area", "kind": "function", "doc": "<p>Get the std of area covered by trajectories per user.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): Input data.</p>\n\n<p>Returns:\n    float: The std of area in hectares.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.DataSetStats", "modulename": "src.laws", "qualname": "DataSetStats", "kind": "class", "doc": "<p>A class for managing dataset statistics, storing various statistical\nmeasures, and saving them into a structured DataFrame.</p>\n\n<p>Attributes:\n    output_dir (str): Directory to save the dataset statistics.\n    record (dict): A dictionary to store temporary statistics\n        before adding them to the dataset.\n    stats_set (pd.DataFrame): A DataFrame containing all the\n        statistics collected for different datasets.</p>\n"}, {"fullname": "src.laws.DataSetStats.__init__", "modulename": "src.laws", "qualname": "DataSetStats.__init__", "kind": "function", "doc": "<p>Initializes the DataSetStats class.</p>\n\n<p>Args:\n    output_dir (str): The directory where output files\n        will be stored.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">output_dir</span></span>)</span>"}, {"fullname": "src.laws.DataSetStats.output_dir", "modulename": "src.laws", "qualname": "DataSetStats.output_dir", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.DataSetStats.record", "modulename": "src.laws", "qualname": "DataSetStats.record", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.DataSetStats.stats_set", "modulename": "src.laws", "qualname": "DataSetStats.stats_set", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.DataSetStats.add_data", "modulename": "src.laws", "qualname": "DataSetStats.add_data", "kind": "function", "doc": "<p>Updates the record dictionary with new data.</p>\n\n<p>Args:\n    data (dict): A dictionary containing key-value\n        pairs of statistics to be added.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.DataSetStats.add_record", "modulename": "src.laws", "qualname": "DataSetStats.add_record", "kind": "function", "doc": "<p>Adds the current record to the stats_set DataFrame\nand resets the record dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Prepocessing", "modulename": "src.laws", "qualname": "Prepocessing", "kind": "class", "doc": "<p>A class containing static methods for preprocessing animal\ntrajectory data.</p>\n"}, {"fullname": "src.laws.Prepocessing.__init__", "modulename": "src.laws", "qualname": "Prepocessing.__init__", "kind": "function", "doc": "<p>Initializes the Prepocessing class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "src.laws.Prepocessing.get_mean_points", "modulename": "src.laws", "qualname": "Prepocessing.get_mean_points", "kind": "function", "doc": "<p>Computes the mean latitude and longitude for each label.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The trajectory dataset.</p>\n\n<p>Returns:\n    TrajectoriesFrame: A new dataset with averaged locations\n        per label.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Prepocessing.set_start_stop_time", "modulename": "src.laws", "qualname": "Prepocessing.set_start_stop_time", "kind": "function", "doc": "<p>Sets the start and stop time for each trajectory point.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The input trajectory dataset.</p>\n\n<p>Returns:\n    TrajectoriesFrame: A dataset with added start and stop times.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Prepocessing.set_crs", "modulename": "src.laws", "qualname": "Prepocessing.set_crs", "kind": "function", "doc": "<p>Converts the coordinate reference system (CRS) of the dataset.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The input dataset.\n    base_csr (int): The current CRS of the dataset.\n    target_crs (int): The target CRS to convert to.</p>\n\n<p>Returns:\n    TrajectoriesFrame: The dataset with the transformed CRS.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>,</span><span class=\"param\">\t<span class=\"n\">base_csr</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">4326</span>,</span><span class=\"param\">\t<span class=\"n\">target_crs</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3857</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Prepocessing.filter_by_min_number", "modulename": "src.laws", "qualname": "Prepocessing.filter_by_min_number", "kind": "function", "doc": "<p>Filters data to include only individuals with a minimum\nnumber of labels.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The input trajectory dataset.\n    min_labels_no (int): The minimum number of labels required.</p>\n\n<p>Returns:\n    TrajectoriesFrame: The filtered dataset.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>,</span><span class=\"param\">\t<span class=\"n\">min_labels_no</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Prepocessing.filter_by_quartiles", "modulename": "src.laws", "qualname": "Prepocessing.filter_by_quartiles", "kind": "function", "doc": "<p>Filters data based on quartile values of distinct locations.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The input dataset.\n    quartile (float): The quartile value (must be 0.25, 0.5, or 0.75).</p>\n\n<p>Returns:\n    TrajectoriesFrame: The filtered dataset.</p>\n\n<p>Raises:\n    ValueError: If the provided quartile value is not one of\n        the allowed values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>,</span><span class=\"param\">\t<span class=\"n\">quartile</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.25</span></span><span class=\"return-annotation\">) -> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Prepocessing.filing_data", "modulename": "src.laws", "qualname": "Prepocessing.filing_data", "kind": "function", "doc": "<p>Processes trajectory data to fill missing values by selecting\nthe most visited location.</p>\n\n<p>Args:\n    data (pd.DataFrame): The input trajectory dataset.</p>\n\n<p>Returns:\n    pd.DataFrame: A processed dataset with missing values filled.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Flexation", "modulename": "src.laws", "qualname": "Flexation", "kind": "class", "doc": "<p>A class used for identifying and fitting statistical distributions to\nsegmented data based on flexation points.</p>\n\n<p>Flexation points are identified using the PELT (Pruned Exact Linear Time)\nchange point detection algorithm. Once flexation points are detected,\nthe data is split into left and right segments, and statistical models\nare fitted to each segment. The goodness of fit is evaluated using\nthe Wasserstein distance between the empirical density and the fitted\nmodel.</p>\n\n<h2 id=\"attributes\">Attributes:</h2>\n\n<p>None</p>\n"}, {"fullname": "src.laws.Flexation.find_distributions", "modulename": "src.laws", "qualname": "Flexation.find_distributions", "kind": "function", "doc": "<p>Identifies the best-fitting distributions for segmented parts of the\ndataset based on flexation points.</p>\n\n<p>The function detects flexation points in the data, evaluates fitting\nscores, and compares the segmented model's performance to the main\nmodel. If a segmented approach improves the fit, it returns the left\nand right distributions along with their respective datasets.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>model : distfit\n    A pre-fitted <code>distfit</code> model used as a reference for comparison.\ndata : ndarray\n    The numerical dataset for which distributions\n        are to be identified.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple or None\n    - If segmentation improves the model fit, returns\n        a tuple containing:\n        - left_model (distfit): The best-fitting distribution\n            for the left segment.\n        - right_model (distfit): The best-fitting distribution\n            for the right segment.\n        - left_set (ndarray): The left segment of the data.\n        - right_set (ndarray): The right segment of the data.\n        - best_point (float): The chosen flexation point that\n            defines segmentation.\n    - If no improvement is found, returns <code>None</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">distfit</span><span class=\"o\">.</span><span class=\"n\">distfit</span><span class=\"o\">.</span><span class=\"n\">distfit</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws", "modulename": "src.laws", "qualname": "Laws", "kind": "class", "doc": "<p>A class for handling statistical data analysis and generating\nreports in PDF format.</p>\n\n<p>This class takes in a dataset, performs statistical analysis,\napplies curve fitting techniques, and generates a PDF report\nsummarizing the results.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>pdf_object : FPDF\n    An instance of the <code>FPDF</code> class used for generating the\n        PDF report.\nstats_frame : DataSetStats\n    An instance of <code>DataSetStats</code> containing statistical\n        information about the dataset.\noutput_path : str\n    The file path where the generated PDF report will be saved.</p>\n\n<h2 id=\"attributes\">Attributes:</h2>\n\n<p>pdf_object : FPDF\n    The PDF object used for report generation.\noutput_path : str\n    The location where the final report will be stored.\nstats_frame : DataSetStats\n    The dataset statistics object containing calculated metrics.\ncurve_fitting : DistributionFitingTools\n    A toolset for fitting distributions to the dataset.</p>\n"}, {"fullname": "src.laws.Laws.__init__", "modulename": "src.laws", "qualname": "Laws.__init__", "kind": "function", "doc": "<h2 id=\"parameters\">Parameters:</h2>\n\n<p>pdf_object : FPDF\n    An instance of the <code>FPDF</code> class used for generating the\n        PDF report.\nstats_frame : DataSetStats\n    An instance of <code>DataSetStats</code> containing statistical\n        information about the dataset.\noutput_path : str\n    The file path where the generated PDF report will be saved.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pdf_object</span><span class=\"p\">:</span> <span class=\"n\">fpdf</span><span class=\"o\">.</span><span class=\"n\">fpdf</span><span class=\"o\">.</span><span class=\"n\">FPDF</span>,</span><span class=\"param\">\t<span class=\"n\">stats_frame</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">laws</span><span class=\"o\">.</span><span class=\"n\">DataSetStats</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "src.laws.Laws.pdf_object", "modulename": "src.laws", "qualname": "Laws.pdf_object", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.Laws.output_path", "modulename": "src.laws", "qualname": "Laws.output_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.Laws.stats_frame", "modulename": "src.laws", "qualname": "Laws.stats_frame", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.Laws.curve_fitting", "modulename": "src.laws", "qualname": "Laws.curve_fitting", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.Laws.log_curve_fitting_resluts", "modulename": "src.laws", "qualname": "Laws.log_curve_fitting_resluts", "kind": "function", "doc": "<p>A decorator that logs and saves curve fitting results\nto a PDF report.</p>\n\n<p>The decorated function is expected to return:</p>\n\n<ul>\n<li>func_name (str): Name of the function.</li>\n<li>best_fit (str): Name of the best-fitting curve.</li>\n<li>param_frame (pd.DataFrame): DataFrame containing\ncurve parameters.</li>\n<li>plot_obj (BytesIO): The plot image object.</li>\n</ul>\n\n<p>The results are logged in <code>self.stats_frame</code>\n    and added to a PDF report.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>func : function\n    The function performing curve fitting.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>function\n    Wrapped function with additional logging and PDF output.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.log_distribution_fitting_resluts", "modulename": "src.laws", "qualname": "Laws.log_distribution_fitting_resluts", "kind": "function", "doc": "<p>A decorator that logs and saves distribution fitting\nresults to a PDF report.</p>\n\n<p>The decorated function is expected to return:</p>\n\n<ul>\n<li>results[0] (str): The name of the fitted distribution.</li>\n<li>results[1] (distfit object): Fitted distribution model.</li>\n<li>results[2] (BytesIO): Distribution plot.</li>\n<li>results[3] (BytesIO): Model plot.</li>\n<li>results[4] (tuple, optional): If present, contains\ninformation about a flexion point.</li>\n</ul>\n\n<p>If a flexion point is detected, it logs both left\nand right distributions and plots them separately.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>func : function\n    The function performing distribution fitting.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>function\n    Wrapped function with additional logging and PDF output.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.log_pnew_estimation", "modulename": "src.laws", "qualname": "Laws.log_pnew_estimation", "kind": "function", "doc": "<p>A decorator that logs and saves P_new estimation results\nto a PDF report.</p>\n\n<p>The decorated function is expected to return:</p>\n\n<ul>\n<li>rho_est (float): Estimated rho parameter.</li>\n<li>gamma_est (float): Estimated gamma parameter.</li>\n<li>DeltaS (np.ndarray): Change in S values for log-log regression.</li>\n<li>S_mid (np.ndarray): Midpoints of S values for log-log regression.</li>\n<li>intercept (float): Intercept of the fitted regression line.</li>\n<li>slope (float): Slope of the fitted regression line.</li>\n<li>nrows (int): Number of time steps for estimation.</li>\n<li>n_data (int): Number of data points.</li>\n</ul>\n\n<p>The results are logged in <code>self.stats_frame</code>\nand visualized in a PDF.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>func : function\n    The function performing P_new estimation.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>function\n    Wrapped function with additional logging and PDF output.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.log_msd_split", "modulename": "src.laws", "qualname": "Laws.log_msd_split", "kind": "function", "doc": "<p>A decorator that logs and saves MSD split results\nto a PDF report.</p>\n\n<p>The decorated function is expected to return:</p>\n\n<ul>\n<li>msd_results (pd.DataFrame): MSD split results\nincluding range and curve parameters.</li>\n<li>plot_obj (BytesIO): The plot image object.</li>\n</ul>\n\n<p>The results are stored in <code>self.stats_frame</code>\nand included in a PDF report.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>func : function\n    The function performing MSD split analysis.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>function\n    Wrapped function with additional logging and PDF output.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.check_curve_fit", "modulename": "src.laws", "qualname": "Laws.check_curve_fit", "kind": "function", "doc": "<p>A decorator that evaluates curve fitting results\nand generates a corresponding plot.</p>\n\n<p>The decorated function is expected to return:</p>\n\n<ul>\n<li>best_fit (str): Name of the best-fitting curve.</li>\n<li>param_frame (pd.DataFrame): DataFrame containing\ncurve parameters.</li>\n<li>y_pred (np.ndarray): Predicted values based on\nthe curve fitting.</li>\n<li>exp_y_pred (np.ndarray or None): Exponential\ncurve prediction (if applicable).</li>\n<li>plot_data (pd.Series or np.ndarray): Data used for fitting.</li>\n<li>labels (list): Axis labels for the plot.</li>\n</ul>\n\n<p>If <code>best_fit</code> is not among {\"linear\", \"expon\", \"expon_neg\"},\nboth the fitted curve and an additional exponential curve\nare plotted. Otherwise, only the fitted curve is plotted.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>func : function\n    The function performing curve fitting.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>function\n    Wrapped function that returns:\n    - func.__name__ (str): Name of the function.\n    - best_fit (str): Best fitting curve name.\n    - param_frame (pd.DataFrame): Parameters of\n        the best fit.\n    - plot_obj (BytesIO): Image object containing\n        the generated plot.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.check_distribution_fit", "modulename": "src.laws", "qualname": "Laws.check_distribution_fit", "kind": "function", "doc": "<p>A decorator that evaluates the results of distribution\nfitting and detects flexation points.</p>\n\n<p>The decorated function is expected to return:</p>\n\n<ul>\n<li>model (distfit object): The best-fitted distribution\nmodel.</li>\n<li>data (pd.Series or np.ndarray): Data used for\ndistribution fitting.</li>\n</ul>\n\n<p>The function generates:</p>\n\n<ul>\n<li>A histogram plot of the fitted distribution.</li>\n<li>A model plot displaying the probability density function (PDF).</li>\n</ul>\n\n<p>If the fitted distribution is not in <code>const.DISTRIBUTIONS</code>\nand the data has at least 4 observations, or if specific conditions\napply (e.g., Pareto or Lognormal with parameter &gt; 2),\nan attempt is made to detect flexation points in the distribution.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>func : function\n    The function performing distribution fitting.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>function\n    Wrapped function that returns:\n    - func.__name__ (str): Name of the function.\n    - model (distfit object): Best-fitting distribution model.\n    - plot_distribution_obj (BytesIO): Image object containing\n        the histogram plot.\n    - plot_model_obj (BytesIO): Image object containing the PDF plot.\n    - flexation_point_detection_results (tuple, optional):\n    If flexation points are found, returns details of left\n    and right distributions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.visitation_frequency", "modulename": "src.laws", "qualname": "Laws.visitation_frequency", "kind": "function", "doc": "<p>Computes the visitation frequency of locations based\non trajectory data.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Computes visitation frequency from trajectory data.</li>\n<li>Averages visitation frequency over a specified\nminimum number of labels.</li>\n<li>Performs curve fitting to find the best function\ndescribing the relationship.</li>\n<li>Returns fitting results, including predictions\nand parameter estimates.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing location visit information.\nmin_labels_no : int\n    Minimum number of labels required for averaging\n        the visitation frequency.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - best_fit (str): Best fitting curve name.\n    - global_params (pd.DataFrame): Parameters of the best fit.\n    - y_pred (np.ndarray): Predicted visitation frequencies.\n    - exp_y_pred (np.ndarray or None): Exponential curve\n        predictions (if applicable).\n    - avg_vf (pd.Series): Averaged visitation frequency data.\n    - labels (list): Axis labels for the plot.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.jump_lengths_distribution", "modulename": "src.laws", "qualname": "Laws.jump_lengths_distribution", "kind": "function", "doc": "<p>Computes the distribution of jump lengths in a trajectory dataset.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Extracts jump lengths from the dataset.</li>\n<li>Removes zero values and converts the data into a distribution.</li>\n<li>Fits multiple statistical distributions and selects the best fit.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing movement data.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - model (distfit object): The fitted distribution model.\n    - jl (pd.Series): The processed jump length data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.waiting_times", "modulename": "src.laws", "qualname": "Laws.waiting_times", "kind": "function", "doc": "<p>Computes the distribution of waiting times in a trajectory dataset.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Calculates the waiting times as the difference between start\nand end times.</li>\n<li>Removes missing and zero values.</li>\n<li>Fits multiple statistical distributions and selects the best fit.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing time-based movement data.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - model (distfit object): The fitted distribution model.\n    - wt (pd.Series): The processed waiting time data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.travel_times", "modulename": "src.laws", "qualname": "Laws.travel_times", "kind": "function", "doc": "<p>Computes the distribution of travel times between locations.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Calculates travel times as the time difference between\nconsecutive trajectory points.</li>\n<li>Removes missing values.</li>\n<li>Fits multiple statistical distributions and selects the best fit.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing time-based movement data.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - model (distfit object): The fitted distribution model.\n    - tt (pd.Series): The processed travel time data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.rog", "modulename": "src.laws", "qualname": "Laws.rog", "kind": "function", "doc": "<p>Computes the distribution of the radius of gyration (RoG).</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Computes the radius of gyration for each trajectory.</li>\n<li>Fits multiple statistical distributions and selects the best fit.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing spatial movement data.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - model (distfit object): The fitted distribution model.\n    - rog (pd.Series): The processed radius of gyration data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.rog_over_time", "modulename": "src.laws", "qualname": "Laws.rog_over_time", "kind": "function", "doc": "<p>Computes the evolution of the radius of gyration (RoG) over time.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Computes the radius of gyration for each trajectory over time.</li>\n<li>Averages the RoG values using a specified number of records.</li>\n<li>Fits a curve to model the evolution of RoG.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing movement data.\nmin_records_no : int\n    Minimum number of records required for averaging.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - best_fit (str): Name of the best fitting model.\n    - global_params (dict): Parameters of the best fit.\n    - y_pred (ndarray): Predicted values from the curve fit.\n    - expon_y_pred (ndarray): Alternative exponential model\n        predictions.\n    - avg_rog (pd.Series): Averaged RoG values over time.\n    - [\"Time\", \"Values\"] (list): Column labels.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.msd_distribution", "modulename": "src.laws", "qualname": "Laws.msd_distribution", "kind": "function", "doc": "<p>Computes the distribution of mean squared displacement (MSD).</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Computes MSD without time evolution.</li>\n<li>Fits multiple statistical distributions and selects the best fit.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing movement data.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - model (distfit object): The fitted distribution model.\n    - msd (pd.Series): The computed MSD values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.msd_curve", "modulename": "src.laws", "qualname": "Laws.msd_curve", "kind": "function", "doc": "<p>Computes the mean squared displacement (MSD) curve over time.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Computes MSD over time.</li>\n<li>Averages MSD values using a specified number of records.</li>\n<li>Fits a curve to model MSD behavior.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing movement data.\nmin_records_no : int\n    Minimum number of records required for averaging.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - best_fit (str): Name of the best fitting model.\n    - global_params (dict): Parameters of the best fit.\n    - y_pred (ndarray): Predicted values from the curve fit.\n    - expon_y_pred (ndarray): Alternative exponential model\n        predictions.\n    - avg_msd (pd.Series): Averaged MSD values over time.\n    - [\"t\", \"MSD\"] (list): Column labels.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.return_time_distribution", "modulename": "src.laws", "qualname": "Laws.return_time_distribution", "kind": "function", "doc": "<p>Computes the distribution of return times.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Identifies return times based on revisited locations.</li>\n<li>Fits a statistical distribution to the return time values.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing labeled locations and timestamps.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - model (distfit object): The fitted distribution model.\n    - rt (pd.Series): The computed return time values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.exploration_time", "modulename": "src.laws", "qualname": "Laws.exploration_time", "kind": "function", "doc": "<p>Computes the distribution of exploration times.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Identifies exploration periods as the time spent in\nnewly visited locations.</li>\n<li>Fits a statistical distribution to the exploration time values.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : TrajectoriesFrame\n    A trajectory dataset containing labeled locations and timestamps.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - model (distfit object): The fitted distribution model.\n    - et (pd.Series): The computed exploration time values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.msd_curve_split", "modulename": "src.laws", "qualname": "Laws.msd_curve_split", "kind": "function", "doc": "<p>Computes and groups MSD curves based on the radius of gyration (RoG).</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Converts trajectory data to a GeoDataFrame.</li>\n<li>Computes the center of mass and starting points for each trajectory.</li>\n<li>Filters data to only include new explorations.</li>\n<li>Computes MSD and RoG values for each group.</li>\n<li>Groups MSD curves based on RoG bins and fits curves to them.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : pd.DataFrame\n    A dataset containing longitude and latitude coordinates.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - msd_results (pd.DataFrame): Summary of MSD curve fitting for\n        different RoG ranges.\n    - buffer (BytesIO): A buffer containing the saved MSD plot.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.distinct_locations_over_time", "modulename": "src.laws", "qualname": "Laws.distinct_locations_over_time", "kind": "function", "doc": "<p>Computes the number of distinct locations visited over time.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Computes the cumulative number of distinct locations visited.</li>\n<li>Fits a curve to model the growth of visited locations over time.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>nrows : int\n    Number of rows in the dataset.\nn_data : int\n    Total data points available.\ndata : pd.Series\n    A dataset containing the count of distinct locations.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - best_fit (str): Name of the best fitting model.\n    - global_params (dict): Parameters of the best fit.\n    - y_pred (ndarray): Predicted values from the curve fit.\n    - expon_y_pred (ndarray): Alternative exponential model\n        predictions.\n    - pd.Series(data): The input data as a pandas Series.\n    - [\"t\", \"S(t)\"] (list): Column labels.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.Laws.estimate_pnew", "modulename": "src.laws", "qualname": "Laws.estimate_pnew", "kind": "function", "doc": "<p>Estimates parameters (rho, gamma) for the probability of\ndiscovering new locations.</p>\n\n<p>The function:</p>\n\n<ul>\n<li>Computes the rate of discovery of new locations (P_new).</li>\n<li>Fits a linear model in log-log space to estimate the parameters.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>nrows : int\n    Number of rows in the dataset.\nn_data : int\n    Total data points available.\nS_t : list or np.array\n    Sequence of distinct locations visited over time.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>tuple:\n    - rho_hat (float): Estimated rho parameter.\n    - gamma_hat (float): Estimated gamma parameter.\n    - DeltaS (np.array): Changes in S(t).\n    - S_mid (np.array): Midpoints of S(t).\n    - intercept (float): Intercept of the log-log regression.\n    - slope (float): Slope of the log-log regression (negative gamma).\n    - nrows (int): Number of rows in the dataset.\n    - n_data (int): Total data points available.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.laws.ScalingLawsCalc", "modulename": "src.laws", "qualname": "ScalingLawsCalc", "kind": "class", "doc": "<p>A class for processing animal trajectory data, performing\nstatistical analyses, and generating a PDF report with results.</p>\n\n<p>Attributes:\n    data (TrajectoriesFrame): The trajectory data of animals.\n    animal_name (str): Name of the dataset.\n    output_dir (str): Directory to store the output files.\n    output_dir_animal (str): Path for the specific dataset output.\n    pdf (FPDF): PDF object to generate reports.\n    stats_frame (DataSetStats): Object for tracking dataset statistics.</p>\n"}, {"fullname": "src.laws.ScalingLawsCalc.__init__", "modulename": "src.laws", "qualname": "ScalingLawsCalc.__init__", "kind": "function", "doc": "<p>Initializes the ScalingLawsCalc class.</p>\n\n<p>Args:\n    data (TrajectoriesFrame): The trajectory dataset.\n    data_name (str): The name of the dataset.\n    output_dir (str): Directory to save output files.\n    stats_frame (DataSetStats): Object to store statistics\n        of the dataset.</p>\n\n<p>Raises:\n    FileExistsError: If the output directory for the dataset\n        already exists.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">humobi</span><span class=\"o\">.</span><span class=\"n\">structures</span><span class=\"o\">.</span><span class=\"n\">trajectory</span><span class=\"o\">.</span><span class=\"n\">TrajectoriesFrame</span>,</span><span class=\"param\">\t<span class=\"n\">data_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">output_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">stats_frame</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">laws</span><span class=\"o\">.</span><span class=\"n\">DataSetStats</span></span>)</span>"}, {"fullname": "src.laws.ScalingLawsCalc.data", "modulename": "src.laws", "qualname": "ScalingLawsCalc.data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.ScalingLawsCalc.animal_name", "modulename": "src.laws", "qualname": "ScalingLawsCalc.animal_name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.ScalingLawsCalc.output_dir", "modulename": "src.laws", "qualname": "ScalingLawsCalc.output_dir", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.ScalingLawsCalc.output_dir_animal", "modulename": "src.laws", "qualname": "ScalingLawsCalc.output_dir_animal", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.ScalingLawsCalc.pdf", "modulename": "src.laws", "qualname": "ScalingLawsCalc.pdf", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.ScalingLawsCalc.stats_frame", "modulename": "src.laws", "qualname": "ScalingLawsCalc.stats_frame", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.laws.ScalingLawsCalc.process_file", "modulename": "src.laws", "qualname": "ScalingLawsCalc.process_file", "kind": "function", "doc": "<p>Main processing function that executes preprocessing,\nstatistical analysis, and generates a PDF report with various\nscaling laws.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.parsers", "modulename": "src.parsers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.parsers.test_data_detector", "modulename": "src.parsers", "qualname": "test_data_detector", "kind": "function", "doc": "<p>Detects if a given ID string is marked as test data.</p>\n\n<p>This function checks whether the provided ID string contains\ncertain keywords such as 'test', 'Ida', or 'Wild', which are\nindicators that the data might be test data.</p>\n\n<p>Args:\n    id (str): The ID string to check for test indicators.</p>\n\n<p>Returns:\n    bool: True if the ID contains 'test', 'Ida',\n        or 'Wild', False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.parse_id", "modulename": "src.parsers", "qualname": "parse_id", "kind": "function", "doc": "<p>Processes the user ID column by removing test data and mapping\nunique IDs to integers.</p>\n\n<p>This function converts the specified user ID column to string\nformat, removes rows where the ID is detected as test data,\nand then maps the remaining unique IDs to integers for easier\nprocessing.</p>\n\n<p>Args:\n    dataframe (pd.DataFrame): The input DataFrame containing the data.\n    cols (list): List of column names where the second column is\n        the user ID.</p>\n\n<p>Returns:\n    pd.DataFrame: The processed DataFrame with test data removed and\n        user IDs mapped to integers.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataframe</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.parse_time", "modulename": "src.parsers", "qualname": "parse_time", "kind": "function", "doc": "<p>Converts the time column to a standard datetime format.</p>\n\n<p>This function processes the specified time column, converting it to a\nstandard datetime format ('%Y-%m-%d %H:%M:%S') for consistency.</p>\n\n<p>Args:\n    dataframe (pd.DataFrame): The input DataFrame containing\n        the data.\n    cols (list): List of column names where the first column\n        is the timestamp.</p>\n\n<p>Returns:\n    pd.DataFrame: The processed DataFrame with the time column\n        converted to a standard format.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataframe</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.data_structuring", "modulename": "src.parsers", "qualname": "data_structuring", "kind": "function", "doc": "<p>Structures the DataFrame by renaming columns and resetting\nthe index.</p>\n\n<p>This function renames the columns of the DataFrame to\n'datetime', 'user_id', 'lon', and 'lat', and then resets\nthe index for a clean output.</p>\n\n<p>Args:\n    dataframe (pd.DataFrame): The input DataFrame.</p>\n\n<p>Returns:\n    pd.DataFrame: The structured DataFrame with renamed\n        columns and reset index.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataframe</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.filter_records", "modulename": "src.parsers", "qualname": "filter_records", "kind": "function", "doc": "<p>Filters out records with zero latitude and longitude,\nand removes duplicate datetime entries.</p>\n\n<p>This function performs two main operations on the provided dataframe:</p>\n\n<ol>\n<li>It removes any rows where both latitude ('lat') and longitude\n('lon') are zero.</li>\n<li>It eliminates any duplicate entries in the 'datetime' column for each\nindividual, based on the index (assumed to be 'user_id' or similar).</li>\n</ol>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>dataframe : pd.DataFrame\n    The dataframe containing at least 'lat', 'lon', and 'datetime' columns.\n    The dataframe is assumed to be indexed by user or individual ID (level 0).</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>pd.DataFrame\n    A filtered dataframe with records having non-zero latitude and longitude,\n    and no duplicate datetime values within each individual group.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataframe</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.filter_by_month_range", "modulename": "src.parsers", "qualname": "filter_by_month_range", "kind": "function", "doc": "<p>Filters the dataset by a specified range of months.</p>\n\n<p>This function allows you to filter data based on a range of months.\nIt compares the 'datetime' column of the dataframe to the specified\nrange (start month and end month) and returns the data within\n(or outside) the range\nbased on the 'in_out' parameter.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>data : pd.DataFrame\n    A dataframe containing a 'datetime' column, which will be used\n        to filter based on the month.\nstart : int\n    The start month (1 for January, 12 for December).\nend : int\n    The end month (1 for January, 12 for December).\nin_out : bool, optional, default=True\n    If True, the function will return rows where the month\n        is between <code>start</code> and <code>end</code> (inclusive).\n    If False, it will return rows where the month is outside this range.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>pd.DataFrame\n    A dataframe containing only the rows that meet the specified\n    month range condition.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">end</span>, </span><span class=\"param\"><span class=\"n\">in_out</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.data_write", "modulename": "src.parsers", "qualname": "data_write", "kind": "function", "doc": "<p>Writes the processed DataFrame to a CSV file.</p>\n\n<p>This function saves the processed DataFrame to a CSV file\nwith a name prefixed by 'parsed_'. If an output path is specified,\nit saves the file in that directory.</p>\n\n<p>Args:\n    dataframe (pd.DataFrame): The processed DataFrame to be saved.\n    filename (str): The original filename of the data.\n    output_path (str, optional): The directory to save the output file.\n        If None, the file will be saved in the current directory.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataframe</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.raw_data_parser", "modulename": "src.parsers", "qualname": "raw_data_parser", "kind": "function", "doc": "<p>Parses and processes raw data from a CSV file.</p>\n\n<p>This function reads a CSV file, processes the specified\ncolumns (e.g., timestamp, user ID, longitude, and latitude),\nand saves the processed data to a new CSV file.</p>\n\n<p>Args:\n    input_path (str): The file path to the input CSV file.\n    cols (list): List of column names to process, in the\n        following order:\n                 - The first column is the timestamp.\n                 - The second column is the user ID.\n                 - The third column is the longitude.\n                 - The fourth column is the latitude.\n    output_path (str, optional): The directory to save the\n        processed CSV file. If None, saves in the current directory.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">breeding_periods</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.multi_raw_data_parser", "modulename": "src.parsers", "qualname": "multi_raw_data_parser", "kind": "function", "doc": "<p>Parses raw data from multiple CSV files.</p>\n\n<p>This function processes multiple CSV files based on\nthe provided dictionary of file paths and corresponding column\nspecifications, saving the results to a specified output path.</p>\n\n<p>Args:\n    data_dict (dict[str, list]): A dictionary where keys are\n        file paths to input CSV files,and values are lists of column\n        names to be processed in the same order:\n            - The first column is the timestamp.\n            - The second column is the user ID.\n            - The third column is the longitude.\n            - The fourth column is the latitude.\n    output_path (str, optional): The directory to save the processed\n        files. If None, saves in the current directory.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">periods_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "src.parsers.parse_data", "modulename": "src.parsers", "qualname": "parse_data", "kind": "function", "doc": "<p>Parses raw data from either a JSON configuration or a single file.</p>\n\n<p>This function supports two modes of operation:</p>\n\n<ol>\n<li>Using a JSON configuration file to process multiple CSV files.</li>\n<li>Parsing a single CSV file with specified columns.</li>\n</ol>\n\n<p>Args:\n    json_source (Optional[str]): Path to a JSON file containing\n        a mapping of file paths and column specifications. Required\n        for processing multiple files.\n    periods (Optional[str]): Path to a JSON file containing additional\n        configuration (e.g., periods) for multi-file processing.\n    path (Optional[str]): Path to a single CSV file for direct processing.\n    cols (Optional[List[str]]): List of column names to be used\n        when processing a single CSV file. Required if <code>path</code> is provided.\n    output_path (Optional[str]): Directory to save processed file(s).\n        Defaults to the current directory if not specified.</p>\n\n<p>Returns:\n    None</p>\n\n<p>Raises:\n    ValueError: If required arguments are missing or invalid.\n    Exception: For any unexpected errors during processing.</p>\n\n<p>Examples:\n    # Example with JSON configuration for multiple files:\n    parse_data(\n        json_source='data/config.json',\n        periods='data/periods.json',\n        output_path='data/processed'\n    )</p>\n\n<pre><code># Example with a single CSV file:\nparse_data(\n    path='data/raw_data.csv',\n    cols=['timestamp', 'user', 'longitude', 'latitude'],\n    output_path='data/processed'\n)\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">json_source</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">periods</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cols</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();